"use strict";(window.webpackChunkweb=window.webpackChunkweb||[]).push([["43612"],{529416:function(t,e,i){let s=i(87406),h=Symbol("max"),r=Symbol("length"),a=Symbol("lengthCalculator"),o=Symbol("allowStale"),l=Symbol("maxAge"),n=Symbol("dispose"),d=Symbol("noDisposeOnSet"),u=Symbol("lruList"),c=Symbol("cache"),f=Symbol("updateAgeOnGet"),p=()=>1,g=(t,e,i)=>{let s=t[c].get(e);if(s){let e=s.value;if(m(t,e)){if(y(t,s),!t[o])return}else i&&(t[f]&&(s.value.now=Date.now()),t[u].unshiftNode(s));return e.value}},m=(t,e)=>{if(!e||!e.maxAge&&!t[l])return!1;let i=Date.now()-e.now;return e.maxAge?i>e.maxAge:t[l]&&i>t[l]},v=t=>{if(t[r]>t[h])for(let e=t[u].tail;t[r]>t[h]&&null!==e;){let i=e.prev;y(t,e),e=i}},y=(t,e)=>{if(e){let i=e.value;t[n]&&t[n](i.key,i.value),t[r]-=i.length,t[c].delete(i.key),t[u].removeNode(e)}};class S{constructor(t,e,i,s,h){this.key=t,this.value=e,this.length=i,this.now=s,this.maxAge=h||0}}let x=(t,e,i,s)=>{let h=i.value;m(t,h)&&(y(t,i),t[o]||(h=void 0)),h&&e.call(s,h.value,h.key,t)};t.exports=class{constructor(t){if("number"==typeof t&&(t={max:t}),t||(t={}),t.max&&("number"!=typeof t.max||t.max<0))throw TypeError("max must be a non-negative number");this[h]=t.max||1/0;let e=t.length||p;if(this[a]="function"!=typeof e?p:e,this[o]=t.stale||!1,t.maxAge&&"number"!=typeof t.maxAge)throw TypeError("maxAge must be a number");this[l]=t.maxAge||0,this[n]=t.dispose,this[d]=t.noDisposeOnSet||!1,this[f]=t.updateAgeOnGet||!1,this.reset()}set max(t){if("number"!=typeof t||t<0)throw TypeError("max must be a non-negative number");this[h]=t||1/0,v(this)}get max(){return this[h]}set allowStale(t){this[o]=!!t}get allowStale(){return this[o]}set maxAge(t){if("number"!=typeof t)throw TypeError("maxAge must be a non-negative number");this[l]=t,v(this)}get maxAge(){return this[l]}set lengthCalculator(t){"function"!=typeof t&&(t=p),t!==this[a]&&(this[a]=t,this[r]=0,this[u].forEach(t=>{t.length=this[a](t.value,t.key),this[r]+=t.length})),v(this)}get lengthCalculator(){return this[a]}get length(){return this[r]}get itemCount(){return this[u].length}rforEach(t,e){e=e||this;for(let i=this[u].tail;null!==i;){let s=i.prev;x(this,t,i,e),i=s}}forEach(t,e){e=e||this;for(let i=this[u].head;null!==i;){let s=i.next;x(this,t,i,e),i=s}}keys(){return this[u].toArray().map(t=>t.key)}values(){return this[u].toArray().map(t=>t.value)}reset(){this[n]&&this[u]&&this[u].length&&this[u].forEach(t=>this[n](t.key,t.value)),this[c]=new Map,this[u]=new s,this[r]=0}dump(){return this[u].map(t=>!m(this,t)&&{k:t.key,v:t.value,e:t.now+(t.maxAge||0)}).toArray().filter(t=>t)}dumpLru(){return this[u]}set(t,e,i){if((i=i||this[l])&&"number"!=typeof i)throw TypeError("maxAge must be a number");let s=i?Date.now():0,o=this[a](e,t);if(this[c].has(t)){if(o>this[h])return y(this,this[c].get(t)),!1;let a=this[c].get(t).value;return this[n]&&!this[d]&&this[n](t,a.value),a.now=s,a.maxAge=i,a.value=e,this[r]+=o-a.length,a.length=o,this.get(t),v(this),!0}let f=new S(t,e,o,s,i);return f.length>this[h]?(this[n]&&this[n](t,e),!1):(this[r]+=f.length,this[u].unshift(f),this[c].set(t,this[u].head),v(this),!0)}has(t){return!!this[c].has(t)&&!m(this,this[c].get(t).value)}get(t){return g(this,t,!0)}peek(t){return g(this,t,!1)}pop(){let t=this[u].tail;return t?(y(this,t),t.value):null}del(t){y(this,this[c].get(t))}load(t){this.reset();let e=Date.now();for(let i=t.length-1;i>=0;i--){let s=t[i],h=s.e||0;if(0===h)this.set(s.k,s.v);else{let t=h-e;t>0&&this.set(s.k,s.v,t)}}}prune(){this[c].forEach((t,e)=>g(this,e,!1))}}},337377:function(t,e,i){i.d(e,{z:()=>p});var s=i(173656);let h="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,r=new Set,a="object"==typeof s&&s?s:{},o=(t,e,i,s)=>{"function"==typeof a.emitWarning?a.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)},l=globalThis.AbortController,n=globalThis.AbortSignal;if(void 0===l){n=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},l=class{constructor(){e()}signal=new n;abort(t){if(!this.signal.aborted){for(let e of(this.signal.reason=t,this.signal.aborted=!0,this.signal._onabort))e(t);this.signal.onabort?.(t)}}};let t=a.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",e=()=>{t&&(t=!1,o("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}Symbol("type");let d=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),u=t=>d(t)?t<=256?Uint8Array:t<=65536?Uint16Array:t<=0x100000000?Uint32Array:t<=Number.MAX_SAFE_INTEGER?c:null:null;class c extends Array{constructor(t){super(t),this.fill(0)}}class f{heap;length;static #t=!1;static create(t){let e=u(t);if(!e)return[];f.#t=!0;let i=new f(t,e);return f.#t=!1,i}constructor(t,e){if(!f.#t)throw TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class p{#e;#i;#s;#h;#r;#a;#o;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#l;#n;#d;#u;#c;#f;#p;#g;#m;#v;#y;#S;#x;#z;#b;#k;#L;#A;static unsafeExposeInternals(t){return{starts:t.#x,ttls:t.#z,sizes:t.#S,keyMap:t.#d,keyList:t.#u,valList:t.#c,next:t.#f,prev:t.#p,get head(){return t.#g},get tail(){return t.#m},free:t.#v,isBackgroundFetch:e=>t.#w(e),backgroundFetch:(e,i,s,h)=>t.#_(e,i,s,h),moveToTail:e=>t.#T(e),indexes:e=>t.#F(e),rindexes:e=>t.#E(e),isStale:e=>t.#D(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#n}get size(){return this.#l}get fetchMethod(){return this.#a}get memoMethod(){return this.#o}get dispose(){return this.#s}get onInsert(){return this.#h}get disposeAfter(){return this.#r}constructor(t){let{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:h,updateAgeOnGet:a,updateAgeOnHas:l,allowStale:n,dispose:c,onInsert:g,disposeAfter:m,noDisposeOnSet:v,noUpdateTTL:y,maxSize:S=0,maxEntrySize:x=0,sizeCalculation:z,fetchMethod:b,memoMethod:k,noDeleteOnFetchRejection:L,noDeleteOnStaleGet:A,allowStaleOnFetchRejection:w,allowStaleOnFetchAbort:_,ignoreFetchAbort:T}=t;if(0!==e&&!d(e))throw TypeError("max option must be a nonnegative integer");let F=e?u(e):Array;if(!F)throw Error("invalid max value: "+e);if(this.#e=e,this.#i=S,this.maxEntrySize=x||this.#i,this.sizeCalculation=z,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw TypeError("sizeCalculation set to non-function")}if(void 0!==k&&"function"!=typeof k)throw TypeError("memoMethod must be a function if defined");if(this.#o=k,void 0!==b&&"function"!=typeof b)throw TypeError("fetchMethod must be a function if specified");if(this.#a=b,this.#k=!!b,this.#d=new Map,this.#u=Array(e).fill(void 0),this.#c=Array(e).fill(void 0),this.#f=new F(e),this.#p=new F(e),this.#g=0,this.#m=0,this.#v=f.create(e),this.#l=0,this.#n=0,"function"==typeof c&&(this.#s=c),"function"==typeof g&&(this.#h=g),"function"==typeof m?(this.#r=m,this.#y=[]):(this.#r=void 0,this.#y=void 0),this.#b=!!this.#s,this.#A=!!this.#h,this.#L=!!this.#r,this.noDisposeOnSet=!!v,this.noUpdateTTL=!!y,this.noDeleteOnFetchRejection=!!L,this.allowStaleOnFetchRejection=!!w,this.allowStaleOnFetchAbort=!!_,this.ignoreFetchAbort=!!T,0!==this.maxEntrySize){if(0!==this.#i&&!d(this.#i))throw TypeError("maxSize must be a positive integer if specified");if(!d(this.maxEntrySize))throw TypeError("maxEntrySize must be a positive integer if specified");this.#O()}if(this.allowStale=!!n,this.noDeleteOnStaleGet=!!A,this.updateAgeOnGet=!!a,this.updateAgeOnHas=!!l,this.ttlResolution=d(s)||0===s?s:1,this.ttlAutopurge=!!h,this.ttl=i||0,this.ttl){if(!d(this.ttl))throw TypeError("ttl must be a positive integer if specified");this.#M()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){let t="LRU_CACHE_UNBOUNDED";r.has(t)||(r.add(t),o("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,p))}}getRemainingTTL(t){return this.#d.has(t)?1/0:0}#M(){let t=new c(this.#e),e=new c(this.#e);this.#z=t,this.#x=e,this.#C=(i,s,r=h.now())=>{if(e[i]=0!==s?r:0,t[i]=s,0!==s&&this.ttlAutopurge){let t=setTimeout(()=>{this.#D(i)&&this.#I(this.#u[i],"expire")},s+1);t.unref&&t.unref()}},this.#W=i=>{e[i]=0!==t[i]?h.now():0},this.#R=(h,r)=>{if(t[r]){let a=t[r],o=e[r];if(!a||!o)return;h.ttl=a,h.start=o,h.now=i||s();let l=h.now-o;h.remainingTTL=a-l}};let i=0,s=()=>{let t=h.now();if(this.ttlResolution>0){i=t;let e=setTimeout(()=>i=0,this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=h=>{let r=this.#d.get(h);if(void 0===r)return 0;let a=t[r],o=e[r];return a&&o?a-((i||s())-o):1/0},this.#D=h=>{let r=e[h],a=t[h];return!!a&&!!r&&(i||s())-r>a}}#W=()=>{};#R=()=>{};#C=()=>{};#D=()=>!1;#O(){let t=new c(this.#e);this.#n=0,this.#S=t,this.#B=e=>{this.#n-=t[e],t[e]=0},this.#U=(t,e,i,s)=>{if(this.#w(e))return 0;if(!d(i))if(s){if("function"!=typeof s)throw TypeError("sizeCalculation must be a function");if(!d(i=s(e,t)))throw TypeError("sizeCalculation return invalid (expect positive integer)")}else throw TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return i},this.#G=(e,i,s)=>{if(t[e]=i,this.#i){let i=this.#i-t[e];for(;this.#n>i;)this.#N(!0)}this.#n+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#n)}}#B=t=>{};#G=(t,e,i)=>{};#U=(t,e,i,s)=>{if(i||s)throw TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#F({allowStale:t=this.allowStale}={}){if(this.#l)for(let e=this.#m;this.#j(e)&&((t||!this.#D(e))&&(yield e),e!==this.#g);)e=this.#p[e]}*#E({allowStale:t=this.allowStale}={}){if(this.#l)for(let e=this.#g;this.#j(e)&&((t||!this.#D(e))&&(yield e),e!==this.#m);)e=this.#f[e]}#j(t){return void 0!==t&&this.#d.get(this.#u[t])===t}*entries(){for(let t of this.#F())void 0===this.#c[t]||void 0===this.#u[t]||this.#w(this.#c[t])||(yield[this.#u[t],this.#c[t]])}*rentries(){for(let t of this.#E())void 0===this.#c[t]||void 0===this.#u[t]||this.#w(this.#c[t])||(yield[this.#u[t],this.#c[t]])}*keys(){for(let t of this.#F()){let e=this.#u[t];void 0===e||this.#w(this.#c[t])||(yield e)}}*rkeys(){for(let t of this.#E()){let e=this.#u[t];void 0===e||this.#w(this.#c[t])||(yield e)}}*values(){for(let t of this.#F())void 0===this.#c[t]||this.#w(this.#c[t])||(yield this.#c[t])}*rvalues(){for(let t of this.#E())void 0===this.#c[t]||this.#w(this.#c[t])||(yield this.#c[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#F()){let s=this.#c[i],h=this.#w(s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,this.#u[i],this))return this.get(this.#u[i],e)}}forEach(t,e=this){for(let i of this.#F()){let s=this.#c[i],h=this.#w(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#u[i],this)}}rforEach(t,e=this){for(let i of this.#E()){let s=this.#c[i],h=this.#w(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#u[i],this)}}purgeStale(){let t=!1;for(let e of this.#E({allowStale:!0}))this.#D(e)&&(this.#I(this.#u[e],"expire"),t=!0);return t}info(t){let e=this.#d.get(t);if(void 0===e)return;let i=this.#c[e],s=this.#w(i)?i.__staleWhileFetching:i;if(void 0===s)return;let r={value:s};if(this.#z&&this.#x){let t=this.#z[e],i=this.#x[e];t&&i&&(r.ttl=t-(h.now()-i),r.start=Date.now())}return this.#S&&(r.size=this.#S[e]),r}dump(){let t=[];for(let e of this.#F({allowStale:!0})){let i=this.#u[e],s=this.#c[e],r=this.#w(s)?s.__staleWhileFetching:s;if(void 0===r||void 0===i)continue;let a={value:r};if(this.#z&&this.#x){a.ttl=this.#z[e];let t=h.now()-this.#x[e];a.start=Math.floor(Date.now()-t)}this.#S&&(a.size=this.#S[e]),t.unshift([i,a])}return t}load(t){for(let[e,i]of(this.clear(),t)){if(i.start){let t=Date.now()-i.start;i.start=h.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;let{ttl:s=this.ttl,start:h,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:o}=i,{noUpdateTTL:l=this.noUpdateTTL}=i,n=this.#U(t,e,i.size||0,a);if(this.maxEntrySize&&n>this.maxEntrySize)return o&&(o.set="miss",o.maxEntrySizeExceeded=!0),this.#I(t,"set"),this;let d=0===this.#l?void 0:this.#d.get(t);if(void 0===d)d=0===this.#l?this.#m:0!==this.#v.length?this.#v.pop():this.#l===this.#e?this.#N(!1):this.#l,this.#u[d]=t,this.#c[d]=e,this.#d.set(t,d),this.#f[this.#m]=d,this.#p[d]=this.#m,this.#m=d,this.#l++,this.#G(d,n,o),o&&(o.set="add"),l=!1,this.#A&&this.#h?.(e,t,"add");else{this.#T(d);let i=this.#c[d];if(e!==i){if(this.#k&&this.#w(i)){i.__abortController.abort(Error("replaced"));let{__staleWhileFetching:e}=i;void 0!==e&&!r&&(this.#b&&this.#s?.(e,t,"set"),this.#L&&this.#y?.push([e,t,"set"]))}else!r&&(this.#b&&this.#s?.(i,t,"set"),this.#L&&this.#y?.push([i,t,"set"]));if(this.#B(d),this.#G(d,n,o),this.#c[d]=e,o){o.set="replace";let t=i&&this.#w(i)?i.__staleWhileFetching:i;void 0!==t&&(o.oldValue=t)}}else o&&(o.set="update");this.#A&&this.onInsert?.(e,t,e===i?"update":"replace")}if(0===s||this.#z||this.#M(),this.#z&&(l||this.#C(d,s,h),o&&this.#R(o,d)),!r&&this.#L&&this.#y){let t,e=this.#y;for(;t=e?.shift();)this.#r?.(...t)}return this}pop(){try{for(;this.#l;){let t=this.#c[this.#g];if(this.#N(!0),this.#w(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#L&&this.#y){let t,e=this.#y;for(;t=e?.shift();)this.#r?.(...t)}}}#N(t){let e=this.#g,i=this.#u[e],s=this.#c[e];return this.#k&&this.#w(s)?s.__abortController.abort(Error("evicted")):(this.#b||this.#L)&&(this.#b&&this.#s?.(s,i,"evict"),this.#L&&this.#y?.push([s,i,"evict"])),this.#B(e),t&&(this.#u[e]=void 0,this.#c[e]=void 0,this.#v.push(e)),1===this.#l?(this.#g=this.#m=0,this.#v.length=0):this.#g=this.#f[e],this.#d.delete(i),this.#l--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,h=this.#d.get(t);if(void 0!==h){let t=this.#c[h];if(this.#w(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#D(h))return i&&this.#W(h),s&&(s.has="hit",this.#R(s,h)),!0;s&&(s.has="stale",this.#R(s,h))}else s&&(s.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,s=this.#d.get(t);if(void 0===s||!i&&this.#D(s))return;let h=this.#c[s];return this.#w(h)?h.__staleWhileFetching:h}#_(t,e,i,s){let h=void 0===e?void 0:this.#c[e];if(this.#w(h))return h;let r=new l,{signal:a}=i;a?.addEventListener("abort",()=>r.abort(a.reason),{signal:r.signal});let o={signal:r.signal,options:i,context:s},n=(s,h=!1)=>{let{aborted:a}=r.signal,l=i.ignoreFetchAbort&&void 0!==s;return(i.status&&(a&&!h?(i.status.fetchAborted=!0,i.status.fetchError=r.signal.reason,l&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),!a||l||h)?(this.#c[e]===u&&(void 0===s?u.__staleWhileFetching?this.#c[e]=u.__staleWhileFetching:this.#I(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,o.options))),s):d(r.signal.reason)},d=s=>{let{aborted:h}=r.signal,a=h&&i.allowStaleOnFetchAbort,o=a||i.allowStaleOnFetchRejection,l=o||i.noDeleteOnFetchRejection;if(this.#c[e]===u&&(l&&void 0!==u.__staleWhileFetching?a||(this.#c[e]=u.__staleWhileFetching):this.#I(t,"fetch")),o)return i.status&&void 0!==u.__staleWhileFetching&&(i.status.returnedStale=!0),u.__staleWhileFetching;if(u.__returned===u)throw s};i.status&&(i.status.fetchDispatched=!0);let u=new Promise((e,s)=>{let a=this.#a?.(t,h,o);a&&a instanceof Promise&&a.then(t=>e(void 0===t?void 0:t),s),r.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>n(t,!0)))})}).then(n,t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),d(t))),c=Object.assign(u,{__abortController:r,__staleWhileFetching:h,__returned:void 0});return void 0===e?(this.set(t,c,{...o.options,status:void 0}),e=this.#d.get(t)):this.#c[e]=c,c}#w(t){return!!this.#k&&!!t&&t instanceof Promise&&t.hasOwnProperty("__staleWhileFetching")&&t.__abortController instanceof l}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:o=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:n=this.noUpdateTTL,noDeleteOnFetchRejection:d=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:c=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=!1,status:m,signal:v}=e;if(!this.#k)return m&&(m.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:m});let y={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:r,noDisposeOnSet:a,size:o,sizeCalculation:l,noUpdateTTL:n,noDeleteOnFetchRejection:d,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:f,ignoreFetchAbort:c,status:m,signal:v},S=this.#d.get(t);if(void 0===S){m&&(m.fetch="miss");let e=this.#_(t,S,y,p);return e.__returned=e}{let e=this.#c[S];if(this.#w(e)){let t=i&&void 0!==e.__staleWhileFetching;return m&&(m.fetch="inflight",t&&(m.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}let h=this.#D(S);if(!g&&!h)return m&&(m.fetch="hit"),this.#T(S),s&&this.#W(S),m&&this.#R(m,S),e;let r=this.#_(t,S,y,p),a=void 0!==r.__staleWhileFetching&&i;return m&&(m.fetch=h?"stale":"refresh",a&&h&&(m.returnedStale=!0)),a?r.__staleWhileFetching:r.__returned=r}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(void 0===i)throw Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#o;if(!i)throw Error("no memoMethod provided to constructor");let{context:s,forceRefresh:h,...r}=e,a=this.get(t,r);if(!h&&void 0!==a)return a;let o=i(t,a,{options:r,context:s});return this.set(t,o,r),o}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:r}=e,a=this.#d.get(t);if(void 0!==a){let e=this.#c[a],o=this.#w(e);return(r&&this.#R(r,a),this.#D(a))?(r&&(r.get="stale"),o)?(r&&i&&void 0!==e.__staleWhileFetching&&(r.returnedStale=!0),i?e.__staleWhileFetching:void 0):(h||this.#I(t,"expire"),r&&i&&(r.returnedStale=!0),i?e:void 0):(r&&(r.get="hit"),o)?e.__staleWhileFetching:(this.#T(a),s&&this.#W(a),e)}r&&(r.get="miss")}#H(t,e){this.#p[e]=t,this.#f[t]=e}#T(t){t!==this.#m&&(t===this.#g?this.#g=this.#f[t]:this.#H(this.#p[t],this.#f[t]),this.#H(this.#m,t),this.#m=t)}delete(t){return this.#I(t,"delete")}#I(t,e){let i=!1;if(0!==this.#l){let s=this.#d.get(t);if(void 0!==s)if(i=!0,1===this.#l)this.#P(e);else{this.#B(s);let i=this.#c[s];if(this.#w(i)?i.__abortController.abort(Error("deleted")):(this.#b||this.#L)&&(this.#b&&this.#s?.(i,t,e),this.#L&&this.#y?.push([i,t,e])),this.#d.delete(t),this.#u[s]=void 0,this.#c[s]=void 0,s===this.#m)this.#m=this.#p[s];else if(s===this.#g)this.#g=this.#f[s];else{let t=this.#p[s];this.#f[t]=this.#f[s];let e=this.#f[s];this.#p[e]=this.#p[s]}this.#l--,this.#v.push(s)}}if(this.#L&&this.#y?.length){let t,e=this.#y;for(;t=e?.shift();)this.#r?.(...t)}return i}clear(){return this.#P("delete")}#P(t){for(let e of this.#E({allowStale:!0})){let i=this.#c[e];if(this.#w(i))i.__abortController.abort(Error("deleted"));else{let s=this.#u[e];this.#b&&this.#s?.(i,s,t),this.#L&&this.#y?.push([i,s,t])}}if(this.#d.clear(),this.#c.fill(void 0),this.#u.fill(void 0),this.#z&&this.#x&&(this.#z.fill(0),this.#x.fill(0)),this.#S&&this.#S.fill(0),this.#g=0,this.#m=0,this.#v.length=0,this.#n=0,this.#l=0,this.#L&&this.#y){let t,e=this.#y;for(;t=e?.shift();)this.#r?.(...t)}}}}}]);